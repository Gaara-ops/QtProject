1.GLEW初始化之后，它会检索你平台中所有可用的扩展库，
  动态的加载并且可以通过简单引用一个头文件来使用
2.顶点缓冲器对象（VBOs）,VBO是用来存储顶点的。
  VBOs是在GPU中加载顶点最有效的方式，他们是可以存储在视频内存的缓冲并且可迅速到达GPU处理

3.光栅化程序将[-1,1]坐标映射到屏幕空间
  光栅化程序根据在draw call中定义的拓扑结构来绘制这些图元

4.OpenGL的可编程管线可以通过下面的图示来表示：
顶点处理器—>几何处理器—>裁剪器—>光栅器（片段处理器）

Vertex Processor顶点处理器阶段负责执行处理经过管线的每一个顶点的vertex shader顶点
着色代码（顶点的数量取决于draw call的参数）。这里顶点着色器还不知道渲染的图元的
topology拓扑结构是怎样的，另外不可以在顶点着色处理器阶段删除丢弃顶点，
每个顶点有且只有一次经过顶点处理器，要经过变换后继续进入管线的下一步。

Geometry Processor几何处理器阶段。在这个阶段，图元的完整数据（比如：所有的顶点数据）
和相邻顶点的数据全部都提供给shader着色器，使其必须眷顾更多的信息，
包括除了顶点本身的其他的一些额外的更全面完整的信息。几何处理器还可以将输出的图形拓扑结构
转换成在draw call中选择的另一种结构。比如：你可以提供一系列的点来产生由两个三角形所构成
的图形（像四边形），也就是顶点链接成三角形图元，两个三角形图元可以构成四边形
（一种叫做billboarding公告板技术的技术）。另外，也可以直接给几何着色器提供多个
顶点然后根据你选择的输出拓扑结构产生多种图元。

开始clip裁剪工作了。这是一个固定功能单元的很明确的一个任务：像前面教程中一样它将所有图元
裁剪到那个单位化的盒子模型内，它另外还会将图元裁剪在Z轴的远近平面范围内（也就是说太远或
太近都不显示）。同时也提供用户自定义的裁剪平面进行自定义的裁剪。经过裁剪后保留下来的顶点
现在会被映射到屏幕空间坐标系上，光栅器将会根据他们的拓扑结构把他们渲染到屏幕上。
举个例子：对于三角形的裁剪就是发现三角形内部所有可见的点，对每个点rasterizer光栅器都会
触发fragment processor片段处理器，现在你可以对每个片段像素定义颜色，颜色可以从一张材质
上取或者使用其他取色技术方式。

上面这三个可编程阶段（vertex processor顶点处理、geometry processor几何处理
和fragment processor片段处理）都是可选的而不是必须的。
如果不在这几个处理器上绑定自己的shaer着色器，那么就会执行一些默认的函数功能，也就是备胎着色器。


Shader着色器的使用跟C/C++程序的创建过程类似。首先你要写一个shader着色器文本并使其在
你的程序中有效可用，这个过程可以通过依次简单的引用这些源码脚本或者从外部文件中加载，注意都是
以字符串数组的形式。然后一个个的编译这些shader文本成shader对象。然后你就可以将这些shader
着色器连接到单个程序中并加载到GPU中。链接这些shader可以使驱动器能够有机会精减这些shader
并根据他们的关系优化他们。例如：可能一个顶点着色器发出的法向量在相应的片段着色器阶段中被忽视，
这样驱动中的GLSL编译器就会移除着色器中与这个法向量相关的函数功能从而更快的执行这个顶点着色器。
如果之后那个着色器又匹配了需要用到那个法向量的片段着色器，然后连接到其他程序后会产生一个
不同的顶点着色器。

5.一致变量（Uniform Variables）
一致变量和普通属性的区别：普通变量所包含的数据是顶点具体化的，所以在每个着色器引入的时候它们
将从顶点缓冲区加载一个新的值；但是一致变量的值在整个draw call中保持不变。

一致变量主要的作用是保存像光照参数（光的位置和方向等）、变换矩阵、材质对象的handle等数据。

6.齐次坐标
使用一个4维向量表示一个3维向量叫做齐次坐标，这在3d图形学中很常用也很有用，第四个分量称作“w”。
第四个分量“w”在从3d到2d的投影变换中起着关键作用。通常对于表示点的矩阵会让w=1，
而对于表示向量的矩阵会让w=0，因为点可以被做变换而向量不可以，你可以改变一个向量的长度和方向，
但是长度和方向一样的所有向量都是相等的，不管他们的起点在哪里，所以我们可以把所有的向量起点
放到原点来看。对于向量设置w=0然后乘以变换矩阵会得到和自身一样的向量。


7.旋转变换

8.插值
3d渲染管线中非常重要的一个部分：光栅器对从顶点着色器传来的变量的插值
为了让一些有意义东西在屏幕上真正显示，你必须将顶点着色器vs的输出变量设置为‘gl_Position’，
gl_Position是一个保存着顶点齐次坐标的4维向量。XYZ分量被W分量所分割（称作视角分割，
这个是教程的重点话题）并且XYZ分量上超出单位化盒子([-1,1])的部分会被裁剪掉。
最终的结果会被转换到屏幕坐标系然后三角形（或者其他支持的图元类型）被光栅器渲染到屏幕上。

光栅器在三角形的三个顶点之间进行插值（或者通过另外一种技术一行一行的插值）并执行片断着色器
遍历三角形的每一个像素。片断着色器会返回光栅器存在颜色缓存中用于显示的像素颜色值（在其他
一些额外的检测之后，比如：深度测试depth test等）。
从顶点着色器传来的其他的变量不会经过上面的步骤。
如果片断着色器没有显式地请求那个变量（你可以使用同一个顶点着色器混合并匹配多个片断着色器）那么
一般的驱动优化会丢弃顶点着色器vs中只是影响该变量的操作（特定的shader程序是
针对vs和fs的配对组合）。但如果片断着色器fs确实使用到了那个变量，光栅器会在光栅化阶段
对其进行插值，并且每一次片断着色器fs的调用都会提供一个匹配特定位置的插值后的值，这意味着
相邻的两个像素的值都略有不同（虽然随着三角形离摄像头越来越远那样会越来越不合适）。

经常情况下依赖插值的两个变量是三角形的法向量和纹理坐标。
顶点的法向量通常是计算包含这个顶点的所有三角形法向量的平均值而得。如果物体不是平坦的话那么
每个三角形的三个顶点的法向量会各不相同，那样我们可以通过插值来计算每个像素的法向量，那些
向量会用于光线的计算，从而产生更逼真可信的光照效果。
插值对于纹理坐标的应用也类似，这些坐标作为模型的一部分定义在每个顶点上。为了用贴图覆盖
三角形你必须对每个像素进行一样的插值操作并给每个像素定义正确的纹理坐标，这些坐标都是插值的结果。

通常会提供一个纹理坐标并从纹理上取样一个颜色值，那个颜色之后会被进行光照计算处理。

9.顺序绘制和索引绘制
顺序绘制是从指定的偏移量依次扫描顶点缓冲区所有图元的每一个顶点，这样很简单易用，但是缺点是
如果一个顶点是多个图元的共同顶点，那么这个顶点将会在顶点缓冲区出现多次，也就是没有顶点
共享的概念。顶点共享是通过索引绘制类的函数来实现的.
索引缓冲中存储着顶点缓冲中的顶点的索引值。扫描索引缓冲和扫描顶点缓冲类似：
每一个X索引按照图元的顶点依次排放。顶点共享就是对于多个图元出现的共同的一个顶点，
只要在索引缓冲中重复顶点在顶点缓冲中的索引即可，不需要将这个顶点在顶点缓冲存储多次。
共享对于内存的高效利用非常重要，因为多数物体都是通过一些由三角形图元组成的封闭的网格表示的，
而多数顶点都会在多个三角形图元中出现作为三角形的其中一个顶点。

在OpenGL中使用索引绘制需要创建并维护一个索引缓冲，这个索引缓冲必须要在draw call之前
绑定到顶点缓冲中，并且需要使用不同的API接口函数。

10.复合变换
向量最开始先是被最右边的矩阵左乘的，然后向量被从右边到左边所有的变换矩阵所变换.
复合矩阵变化的时候注意各个矩阵相乘的顺序,最先变换的放在最右边乘

11.透视投影
对图形的透视变换需要提供四个参数：
1.屏幕宽高比：举行屏幕的宽高比例是投影的目标；
2.垂直视野：相机窗口看向3d世界的垂直方向上的角度；
3.Z轴近平面的位置：近平面用于将离相机太近的物体裁剪掉；
4.Z轴远平面的位置：远平面用于将离相机太远的物体裁剪掉；

屏幕宽高比
是一个必要的参数，因为我们要在一个宽高相等的单位化的盒子内展示所有的坐标系，而通常
屏幕的宽度是大于屏幕的高度的，所以需要在水平方向上的轴线上布置更加密集的坐标点，竖直
方向上相对稀疏。这样经过变换，我们就可以在保证看到更宽阔屏幕图像的需求下，根据X轴在
单位盒子空间内的比例，在X方向上添加更多的X坐标。

垂直视野
允许我们通过调整来放大或者缩小3d世界中的视野
投影的坐标系和屏幕是映射匹配的，相机的位置不会产生任何影响

12.相机空间
基本变换，用来改变物体的位置（平移变换）、方向（旋转变换）、尺寸（缩放变换），
可以将物体至于3d世界任意位置
透视投影变换用于将3d世界的一个顶点位置投射到2d世界

对于相机的旋转变换，我们需要在保持物体和相机距离不变的情况下移动物体（也就是绕相机中心
在一个球面范围上移动了，相机中心位于原点），同时物体的实际移动方向和相机旋转的方向
是相反的，对于相机的平移变换也一样的道理。
线性独立意味着我们找不到三个不是全为0的x,y,z值使得
x*(1,0,0) + y*(0,1,0) + z*(0,0,1) = (0,0,0)，从集合的角度，
就是说任意两个单位向量所在的平面和第三个向量垂直（平面XY和Z轴垂直等等）

标量投影是任意一个向量A和一个单位向量B的点积，点积的结果就是
向量A在单位向量B方向上的长度，也就是A在单位向量B上的投影了




