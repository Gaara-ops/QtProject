1.GLEW初始化之后，它会检索你平台中所有可用的扩展库，
  动态的加载并且可以通过简单引用一个头文件来使用
2.顶点缓冲器对象（VBOs）,VBO是用来存储顶点的。
  VBOs是在GPU中加载顶点最有效的方式，他们是可以存储在视频内存的缓冲并且可迅速到达GPU处理

3.光栅化程序将[-1,1]坐标映射到屏幕空间
  光栅化程序根据在draw call中定义的拓扑结构来绘制这些图元

4.OpenGL的可编程管线可以通过下面的图示来表示：
顶点处理器—>几何处理器—>裁剪器—>光栅器（片段处理器）

Vertex Processor顶点处理器阶段负责执行处理经过管线的每一个顶点的vertex shader顶点
着色代码（顶点的数量取决于draw call的参数）。这里顶点着色器还不知道渲染的图元的
topology拓扑结构是怎样的，另外不可以在顶点着色处理器阶段删除丢弃顶点，
每个顶点有且只有一次经过顶点处理器，要经过变换后继续进入管线的下一步。

Geometry Processor几何处理器阶段。在这个阶段，图元的完整数据（比如：所有的顶点数据）
和相邻顶点的数据全部都提供给shader着色器，使其必须眷顾更多的信息，
包括除了顶点本身的其他的一些额外的更全面完整的信息。几何处理器还可以将输出的图形拓扑结构
转换成在draw call中选择的另一种结构。比如：你可以提供一系列的点来产生由两个三角形所构成
的图形（像四边形），也就是顶点链接成三角形图元，两个三角形图元可以构成四边形
（一种叫做billboarding公告板技术的技术）。另外，也可以直接给几何着色器提供多个
顶点然后根据你选择的输出拓扑结构产生多种图元。

开始clip裁剪工作了。这是一个固定功能单元的很明确的一个任务：像前面教程中一样它将所有图元
裁剪到那个单位化的盒子模型内，它另外还会将图元裁剪在Z轴的远近平面范围内（也就是说太远或
太近都不显示）。同时也提供用户自定义的裁剪平面进行自定义的裁剪。经过裁剪后保留下来的顶点
现在会被映射到屏幕空间坐标系上，光栅器将会根据他们的拓扑结构把他们渲染到屏幕上。
举个例子：对于三角形的裁剪就是发现三角形内部所有可见的点，对每个点rasterizer光栅器都会
触发fragment processor片段处理器，现在你可以对每个片段像素定义颜色，颜色可以从一张材质
上取或者使用其他取色技术方式。

上面这三个可编程阶段（vertex processor顶点处理、geometry processor几何处理
和fragment processor片段处理）都是可选的而不是必须的。
如果不在这几个处理器上绑定自己的shaer着色器，那么就会执行一些默认的函数功能，也就是备胎着色器。


Shader着色器的使用跟C/C++程序的创建过程类似。首先你要写一个shader着色器文本并使其在
你的程序中有效可用，这个过程可以通过依次简单的引用这些源码脚本或者从外部文件中加载，注意都是
以字符串数组的形式。然后一个个的编译这些shader文本成shader对象。然后你就可以将这些shader
着色器连接到单个程序中并加载到GPU中。链接这些shader可以使驱动器能够有机会精减这些shader
并根据他们的关系优化他们。例如：可能一个顶点着色器发出的法向量在相应的片段着色器阶段中被忽视，
这样驱动中的GLSL编译器就会移除着色器中与这个法向量相关的函数功能从而更快的执行这个顶点着色器。
如果之后那个着色器又匹配了需要用到那个法向量的片段着色器，然后连接到其他程序后会产生一个
不同的顶点着色器。

5.一致变量（Uniform Variables）
一致变量和普通属性的区别：普通变量所包含的数据是顶点具体化的，所以在每个着色器引入的时候它们
将从顶点缓冲区加载一个新的值；但是一致变量的值在整个draw call中保持不变。

一致变量主要的作用是保存像光照参数（光的位置和方向等）、变换矩阵、材质对象的handle等数据。

6.齐次坐标
使用一个4维向量表示一个3维向量叫做齐次坐标，这在3d图形学中很常用也很有用，第四个分量称作“w”。
第四个分量“w”在从3d到2d的投影变换中起着关键作用。通常对于表示点的矩阵会让w=1，
而对于表示向量的矩阵会让w=0，因为点可以被做变换而向量不可以，你可以改变一个向量的长度和方向，
但是长度和方向一样的所有向量都是相等的，不管他们的起点在哪里，所以我们可以把所有的向量起点
放到原点来看。对于向量设置w=0然后乘以变换矩阵会得到和自身一样的向量。


7.旋转变换

8.插值
3d渲染管线中非常重要的一个部分：光栅器对从顶点着色器传来的变量的插值
为了让一些有意义东西在屏幕上真正显示，你必须将顶点着色器vs的输出变量设置为‘gl_Position’，
gl_Position是一个保存着顶点齐次坐标的4维向量。XYZ分量被W分量所分割（称作视角分割，
这个是教程的重点话题）并且XYZ分量上超出单位化盒子([-1,1])的部分会被裁剪掉。
最终的结果会被转换到屏幕坐标系然后三角形（或者其他支持的图元类型）被光栅器渲染到屏幕上。

光栅器在三角形的三个顶点之间进行插值（或者通过另外一种技术一行一行的插值）并执行片断着色器
遍历三角形的每一个像素。片断着色器会返回光栅器存在颜色缓存中用于显示的像素颜色值（在其他
一些额外的检测之后，比如：深度测试depth test等）。
从顶点着色器传来的其他的变量不会经过上面的步骤。
如果片断着色器没有显式地请求那个变量（你可以使用同一个顶点着色器混合并匹配多个片断着色器）那么
一般的驱动优化会丢弃顶点着色器vs中只是影响该变量的操作（特定的shader程序是
针对vs和fs的配对组合）。但如果片断着色器fs确实使用到了那个变量，光栅器会在光栅化阶段
对其进行插值，并且每一次片断着色器fs的调用都会提供一个匹配特定位置的插值后的值，这意味着
相邻的两个像素的值都略有不同（虽然随着三角形离摄像头越来越远那样会越来越不合适）。

经常情况下依赖插值的两个变量是三角形的法向量和纹理坐标。
顶点的法向量通常是计算包含这个顶点的所有三角形法向量的平均值而得。如果物体不是平坦的话那么
每个三角形的三个顶点的法向量会各不相同，那样我们可以通过插值来计算每个像素的法向量，那些
向量会用于光线的计算，从而产生更逼真可信的光照效果。
插值对于纹理坐标的应用也类似，这些坐标作为模型的一部分定义在每个顶点上。为了用贴图覆盖
三角形你必须对每个像素进行一样的插值操作并给每个像素定义正确的纹理坐标，这些坐标都是插值的结果。

通常会提供一个纹理坐标并从纹理上取样一个颜色值，那个颜色之后会被进行光照计算处理。

9.顺序绘制和索引绘制
顺序绘制是从指定的偏移量依次扫描顶点缓冲区所有图元的每一个顶点，这样很简单易用，但是缺点是
如果一个顶点是多个图元的共同顶点，那么这个顶点将会在顶点缓冲区出现多次，也就是没有顶点
共享的概念。顶点共享是通过索引绘制类的函数来实现的.
索引缓冲中存储着顶点缓冲中的顶点的索引值。扫描索引缓冲和扫描顶点缓冲类似：
每一个X索引按照图元的顶点依次排放。顶点共享就是对于多个图元出现的共同的一个顶点，
只要在索引缓冲中重复顶点在顶点缓冲中的索引即可，不需要将这个顶点在顶点缓冲存储多次。
共享对于内存的高效利用非常重要，因为多数物体都是通过一些由三角形图元组成的封闭的网格表示的，
而多数顶点都会在多个三角形图元中出现作为三角形的其中一个顶点。

在OpenGL中使用索引绘制需要创建并维护一个索引缓冲，这个索引缓冲必须要在draw call之前
绑定到顶点缓冲中，并且需要使用不同的API接口函数。

10.复合变换
向量最开始先是被最右边的矩阵左乘的，然后向量被从右边到左边所有的变换矩阵所变换.
复合矩阵变化的时候注意各个矩阵相乘的顺序,最先变换的放在最右边乘

11.透视投影
对图形的透视变换需要提供四个参数：
1.屏幕宽高比：举行屏幕的宽高比例是投影的目标；
2.垂直视野：相机窗口看向3d世界的垂直方向上的角度；
3.Z轴近平面的位置：近平面用于将离相机太近的物体裁剪掉；
4.Z轴远平面的位置：远平面用于将离相机太远的物体裁剪掉；

屏幕宽高比
是一个必要的参数，因为我们要在一个宽高相等的单位化的盒子内展示所有的坐标系，而通常
屏幕的宽度是大于屏幕的高度的，所以需要在水平方向上的轴线上布置更加密集的坐标点，竖直
方向上相对稀疏。这样经过变换，我们就可以在保证看到更宽阔屏幕图像的需求下，根据X轴在
单位盒子空间内的比例，在X方向上添加更多的X坐标。

垂直视野
允许我们通过调整来放大或者缩小3d世界中的视野
投影的坐标系和屏幕是映射匹配的，相机的位置不会产生任何影响

12.相机空间
基本变换，用来改变物体的位置（平移变换）、方向（旋转变换）、尺寸（缩放变换），
可以将物体至于3d世界任意位置
透视投影变换用于将3d世界的一个顶点位置投射到2d世界

对于相机的旋转变换，我们需要在保持物体和相机距离不变的情况下移动物体（也就是绕相机中心
在一个球面范围上移动了，相机中心位于原点），同时物体的实际移动方向和相机旋转的方向
是相反的，对于相机的平移变换也一样的道理。
线性独立意味着我们找不到三个不是全为0的x,y,z值使得
x*(1,0,0) + y*(0,1,0) + z*(0,0,1) = (0,0,0)，从集合的角度，
就是说任意两个单位向量所在的平面和第三个向量垂直（平面XY和Z轴垂直等等）

标量投影是任意一个向量A和一个单位向量B的点积，点积的结果就是
向量A在单位向量B方向上的长度，也就是A在单位向量B上的投影了

13.键盘控制
glutSpecialFunc()。当“专用功能按键”按下时触发。
专用按键主要包括：功能键、方向键，以及PAGE-UP/PAGE-DOWN/HOME/END/INSERT这些按键

glutKeyboardFunc()。获取常规按键（字母键和数字键）的触发事件


14.鼠标控制


15.纹理贴图
实现纹理贴图步骤：
a.将一张贴图加载到OpenGL中
b.提供纹理坐标和顶点（将纹理对应匹配到顶点上）
c.使用纹理坐标从纹理中进行取样操作取得像素颜色

关于‘取样’
在GPU光栅化三角形阶段，会对纹理坐标进行插值计算并覆盖到整个三角形面上，并且在片段着色器中
开发者要将这些坐标跟纹理进行匹配。
取样的结果叫做‘纹素’（纹理中的一个像素）。
纹素通常包含一个颜色值用于画屏幕上对应的一个像素。纹素可以包含不同的数据类型来产生不同的效果。

OpenGL支持几种不同类型的纹理：1D,2D,3D,立方体等

纹理坐标是定义在‘纹理空间’的，也就是定义在单位化的[0,1]范围内。
通常的约定是使用U和V作为纹理空间中的轴线，U对应于2D坐标系的X轴，V对应于Y轴。
在OpenGL中对UV轴上的值的处理方式为：在U轴上从左往右递增，V轴上从下往上递增（原点在左下角）

过滤：线性插值
采样操作通常发生在片段着色器中并通过一个特殊的函数来完成

着色器中的纹理对象，纹理单元，取样器对象和取样器一致变量

纹理对象并不是直接绑定到shader上的（事实上是采样阶段发生的地方），而是绑定到‘纹理单元’上，
‘纹理单元’的索引会被传到shader中，因此shader是通过纹理单元得到纹理对象的

ImageMagick：一个免费的库支持多种图像格式


16.环境光
光照模型对于场景的渲染很重要，可以增添很多真实性效果。
之所以叫做‘光照模型’是因为你不能去准确的去模拟现实世界的光照过程，因为现实中的光照是由
大量的叫做‘光子’的粒子组成，并且同时有波动性和离子性（光的波粒二象性）

基本的光照模型主要包括‘环境光/漫反射/镜面反射
环境光：也就被建模为一个没有光源、没有方向并且对场景中的所有物体产生相同的点亮效果的一种光。
漫反射光:强调的是光照射到物体表面的角度对物体亮度效果的影响。
        漫反射光最重要的特性就是光的方向.
镜面反射光:与其说是光本身的特性不如说是物体的一种属性,
          计算镜面反射光既要考虑光的入射角度又要考虑观察者的视角位置

a.‘平行光directional light’的光源.平行光有特定的方向但是没有特定的光源.
平行光的另外一个重要性质是不管它离物体多远亮度是不变的（没有实际位置，不考虑光的衰减）
b.点光源相反，点光源会随着距离增加而逐渐衰弱（灯泡就是个很好的例子）

通过同时增大或者缩小各颜色通道(r,g,b)的值，可以在保持颜色不变的情况下使其变量或者变暗
光只能暴露显示物体的实际颜色，但不能往上添加颜色。
光源的颜色（那个三元组）和物体表面的颜色相乘就可以得到反射回来的颜色了.

环境光在很多情况下会被尽量的避免去考虑，因为它看上去有点太人工化，简单的实现并不会使场景更真实

17.漫反射光
漫射光和环境光的主要不同是漫射光的特性依赖光线的方向，而环境光完全忽略光的方向。
漫射光还增加了一个光强度的变化现象，光的强度大小还取决于光线和物体表面的角度。
光想的强度和光线方向与物体表面法线夹角的余弦值成正比（夹角越大光强度越小）
顶点法线是共用一个顶点的所有三角形法线的平均值。--优化多边形之间边界的颜色变化不平滑。







