1.GLEW初始化之后，它会检索你平台中所有可用的扩展库，
  动态的加载并且可以通过简单引用一个头文件来使用
2.顶点缓冲器对象（VBOs）,VBO是用来存储顶点的。
  VBOs是在GPU中加载顶点最有效的方式，他们是可以存储在视频内存的缓冲并且可迅速到达GPU处理

3.光栅化程序将[-1,1]坐标映射到屏幕空间
  光栅化程序根据在draw call中定义的拓扑结构来绘制这些图元

4.OpenGL的可编程管线可以通过下面的图示来表示：
顶点处理器—>几何处理器—>裁剪器—>光栅器（片段处理器）

Vertex Processor顶点处理器阶段负责执行处理经过管线的每一个顶点的vertex shader顶点
着色代码（顶点的数量取决于draw call的参数）。这里顶点着色器还不知道渲染的图元的
topology拓扑结构是怎样的，另外不可以在顶点着色处理器阶段删除丢弃顶点，
每个顶点有且只有一次经过顶点处理器，要经过变换后继续进入管线的下一步。

Geometry Processor几何处理器阶段。在这个阶段，图元的完整数据（比如：所有的顶点数据）
和相邻顶点的数据全部都提供给shader着色器，使其必须眷顾更多的信息，
包括除了顶点本身的其他的一些额外的更全面完整的信息。几何处理器还可以将输出的图形拓扑结构
转换成在draw call中选择的另一种结构。比如：你可以提供一系列的点来产生由两个三角形所构成
的图形（像四边形），也就是顶点链接成三角形图元，两个三角形图元可以构成四边形
（一种叫做billboarding公告板技术的技术）。另外，也可以直接给几何着色器提供多个
顶点然后根据你选择的输出拓扑结构产生多种图元。

开始clip裁剪工作了。这是一个固定功能单元的很明确的一个任务：像前面教程中一样它将所有图元
裁剪到那个单位化的盒子模型内，它另外还会将图元裁剪在Z轴的远近平面范围内（也就是说太远或
太近都不显示）。同时也提供用户自定义的裁剪平面进行自定义的裁剪。经过裁剪后保留下来的顶点
现在会被映射到屏幕空间坐标系上，光栅器将会根据他们的拓扑结构把他们渲染到屏幕上。
举个例子：对于三角形的裁剪就是发现三角形内部所有可见的点，对每个点rasterizer光栅器都会
触发fragment processor片段处理器，现在你可以对每个片段像素定义颜色，颜色可以从一张材质
上取或者使用其他取色技术方式。

上面这三个可编程阶段（vertex processor顶点处理、geometry processor几何处理
和fragment processor片段处理）都是可选的而不是必须的。
如果不在这几个处理器上绑定自己的shaer着色器，那么就会执行一些默认的函数功能，也就是备胎着色器。


Shader着色器的使用跟C/C++程序的创建过程类似。首先你要写一个shader着色器文本并使其在
你的程序中有效可用，这个过程可以通过依次简单的引用这些源码脚本或者从外部文件中加载，注意都是
以字符串数组的形式。然后一个个的编译这些shader文本成shader对象。然后你就可以将这些shader
着色器连接到单个程序中并加载到GPU中。链接这些shader可以使驱动器能够有机会精减这些shader
并根据他们的关系优化他们。例如：可能一个顶点着色器发出的法向量在相应的片段着色器阶段中被忽视，
这样驱动中的GLSL编译器就会移除着色器中与这个法向量相关的函数功能从而更快的执行这个顶点着色器。
如果之后那个着色器又匹配了需要用到那个法向量的片段着色器，然后连接到其他程序后会产生一个
不同的顶点着色器。

5.一致变量（Uniform Variables）
一致变量和普通属性的区别：普通变量所包含的数据是顶点具体化的，所以在每个着色器引入的时候它们
将从顶点缓冲区加载一个新的值；但是一致变量的值在整个draw call中保持不变。

一致变量主要的作用是保存像光照参数（光的位置和方向等）、变换矩阵、材质对象的handle等数据。

6.齐次坐标
使用一个4维向量表示一个3维向量叫做齐次坐标，这在3d图形学中很常用也很有用，第四个分量称作“w”。
第四个分量“w”在从3d到2d的投影变换中起着关键作用。通常对于表示点的矩阵会让w=1，
而对于表示向量的矩阵会让w=0，因为点可以被做变换而向量不可以，你可以改变一个向量的长度和方向，
但是长度和方向一样的所有向量都是相等的，不管他们的起点在哪里，所以我们可以把所有的向量起点
放到原点来看。对于向量设置w=0然后乘以变换矩阵会得到和自身一样的向量。


