1.GLEW初始化之后，它会检索你平台中所有可用的扩展库，
  动态的加载并且可以通过简单引用一个头文件来使用
2.顶点缓冲器对象（VBOs）,VBO是用来存储顶点的。
  VBOs是在GPU中加载顶点最有效的方式，他们是可以存储在视频内存的缓冲并且可迅速到达GPU处理

3.光栅化程序将[-1,1]坐标映射到屏幕空间
  光栅化程序根据在draw call中定义的拓扑结构来绘制这些图元

4.OpenGL的可编程管线可以通过下面的图示来表示：
顶点处理器—>几何处理器—>裁剪器—>光栅器（片段处理器）

Vertex Processor顶点处理器阶段负责执行处理经过管线的每一个顶点的vertex shader顶点
着色代码（顶点的数量取决于draw call的参数）。这里顶点着色器还不知道渲染的图元的
topology拓扑结构是怎样的，另外不可以在顶点着色处理器阶段删除丢弃顶点，
每个顶点有且只有一次经过顶点处理器，要经过变换后继续进入管线的下一步。

Geometry Processor几何处理器阶段。在这个阶段，图元的完整数据（比如：所有的顶点数据）
和相邻顶点的数据全部都提供给shader着色器，使其必须眷顾更多的信息，
包括除了顶点本身的其他的一些额外的更全面完整的信息。几何处理器还可以将输出的图形拓扑结构
转换成在draw call中选择的另一种结构。比如：你可以提供一系列的点来产生由两个三角形所构成
的图形（像四边形），也就是顶点链接成三角形图元，两个三角形图元可以构成四边形
（一种叫做billboarding公告板技术的技术）。另外，也可以直接给几何着色器提供多个
顶点然后根据你选择的输出拓扑结构产生多种图元。

开始clip裁剪工作了。这是一个固定功能单元的很明确的一个任务：像前面教程中一样它将所有图元
裁剪到那个单位化的盒子模型内，它另外还会将图元裁剪在Z轴的远近平面范围内（也就是说太远或
太近都不显示）。同时也提供用户自定义的裁剪平面进行自定义的裁剪。经过裁剪后保留下来的顶点
现在会被映射到屏幕空间坐标系上，光栅器将会根据他们的拓扑结构把他们渲染到屏幕上。
举个例子：对于三角形的裁剪就是发现三角形内部所有可见的点，对每个点rasterizer光栅器都会
触发fragment processor片段处理器，现在你可以对每个片段像素定义颜色，颜色可以从一张材质
上取或者使用其他取色技术方式。

上面这三个可编程阶段（vertex processor顶点处理、geometry processor几何处理
和fragment processor片段处理）都是可选的而不是必须的。
如果不在这几个处理器上绑定自己的shaer着色器，那么就会执行一些默认的函数功能，也就是备胎着色器。


